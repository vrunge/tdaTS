% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/segment_to_segments.R
\name{segment_to_segments}
\alias{segment_to_segments}
\title{segment_to_2segments}
\usage{
segment_to_segments(
  n = 1000,
  change = 0.5,
  time_sampling = "unif",
  gap = 0.5,
  nb_levels = 20,
  X_rate = 1
)
}
\arguments{
\item{n}{Overall number of points to draw}

\item{change}{Relative location of the change (example: \code{change = 0.5} = at the middle of the data, time goes from 0 to 1 with this function)}

\item{time_sampling}{\code{"unif"} (uniform continuous time sampling) or \code{"discrete"} (data are located at discrete regular time steps)}

\item{gap}{Final gap between the 2 segments}

\item{nb_levels}{number of time steps (for option \code{sampling = "discrete"}). The n points are distributed uniformily (same amount by level when possible) on all the \code{nb_levels}.}

\item{X_rate}{regular-in-time multiplicative factor for the x axis (x-coordinates are multiplicated by \code{(X_rate*time + 1 - time)} where \code{time} goes from 0 to 1)}
}
\value{
tibble with 3 columns (t,x,y) and n rows
}
\description{
Function generating a tibble with 3 columns named (t,x,y) with data in the (x,y) plane forming a segment cut into two smaller segments over time. The transformation is "isometric" as the length of the initial segment (= 1) at time t=0 is preserved at all time steps with \code{X_Rate = 1}
}
\examples{
segment_to_circle()
}
